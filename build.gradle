/**
 *
 *  Gradle Build which will create a wildfly modules based on existing input data from an import xml file
 *
 *
 */


import org.apache.commons.io.FileUtils
import groovy.xml.Namespace

import javax.xml.namespace.QName

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "io.spring.gradle:dependency-management-plugin:0.6.1.RELEASE"
        classpath "commons-io:commons-io:2.5"
    }
}

apply plugin: 'java'
apply plugin: "io.spring.dependency-management"

/**
 * Variables
 */
def importModuleFile="${projectDir}${File.separator}import.xml"
def moduleNames = new ArrayList<String>();
def moduleRoot = "${projectDir}${File.separator}modules"
def moduleSample ="${projectDir}${File.separator}module.xml"

/*************************  project dependencies ******************/

configurations {
    modulirisation
}

repositories {
    mavenCentral()
}

dependencyManagement {
    imports {
        mavenBom 'io.spring.platform:platform-bom:2.0.7.RELEASE'
    }
}

/************************** TASKS *********************************/
/**
 * loadDependecies Task
 *
 */
task loadDependecies() {
    onlyIf {
        file(importModuleFile).exists()
    }
    doLast{
        def module = new XmlParser().parseText(file(importModuleFile).text)
        module.resources.resource.each{ tag->
            println "available tags are :" + tag.@name
            String groupName = tag.@group +":"+tag.@name
            moduleNames.add(groupName)
        }
        def managedVersions = dependencyManagement.managedVersions
        managedVersions.findAll{ ver->
            String group = ver.key
            println "checking ver against moduleName:" + group
            moduleNames.contains(group)
        }.each{ ver->
            String group = ver.key
            String version = ver.value
            println "adding module :" + group + " with version:" +version
            String dependencySpec = group +":" +version
            def conf = configurations.create(group)
            conf.extendsFrom(configurations.modulirisation)
            conf.description = group
            configurations.add(conf)
            dependencies.add(group, dependencySpec,{ transitive = false}) // just temporarily, we will later control that via xml
        }
    }
}

/**
 * Task to build modules from the modulirisation based config only
 */
task buildModules(dependsOn:loadDependecies){
    doLast{
        configurations.findAll{ configuration ->
            def parent = configuration.getExtendsFrom()[0]
            parent == configurations.modulirisation
        }.each{ configuration ->
            buildModule(configuration, moduleRoot, file(moduleSample), file(importModuleFile))
        }
    }
}

/**
 *
 * @param resource
 * @param destination
 */
def buildModule(Configuration config, String destination, File moduleSample, File importFile) {
    //println "***************** ${config.description}" + "|" + config.files
    //println "destination is:"+destination
    def dir = destination + File.separator + config.description.replace(".", File.separator).replace(":", File.separator) + File.separator + "main"
    //println  "destination dir ="+dir
    // destroy modules root if exists
    GFileUtils.deleteDirectory(file(dir))
    // create folder structure in modules root
    file(dir).mkdirs()
    def destDir = file(dir)
    config.getFiles().each { file ->
        FileUtils.copyFileToDirectory(file, destDir)
    }

    FileUtils.copyFileToDirectory(moduleSample, destDir)
    def targetXml = file("${dir}${File.separator}module.xml")
    def targetXmlFile = file(targetXml);
    def parser = new XmlParser()
    def xml = parser.parseText(targetXmlFile.text)
    xml.@name = config.description // set the name of the module
    // set the files in the module
    destDir.listFiles().findAll{ file->
        file.name != 'module.xml'
    }.each{ depFile ->
        new Node (xml.resources[0], 'resource-root', [path: depFile.getName()])
    }
    // set the dependencies in the module
    def importXml = parser.parseText(importFile.text)
    importXml.resources.resource.find{ tag->
        String groupName = tag.@group +":"+tag.@name
        println "equality:*****"
        println groupName
        println config.description
        groupName == config.description
    }.each{ tag->
        //println "matched dependecies:" + tag
        tag.dependency.each{ dep->
            println dep
            new Node (xml.dependencies[0], 'module', [name: dep.@module])
        }
    }
    new XmlNodePrinter(new PrintWriter(targetXmlFile)).print(xml)
}